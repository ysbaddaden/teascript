scopes    = require('../scopes')
Splat     = require('../expressions/splat')
Dot       = require('../expressions/dot')
Operation = require('../expressions/operation')

def TFunction(name, args, body, parent, type)
  self.name    = name
  self.args    = args || []
  self.body    = body
  self.parent  = parent
  self.type    = type
  self.methods = name ? self.extract('-') : []
  self.statics = name ? self.extract('+') : []

  def compile(options = {})
    rs = nil
    scopes.withScope(-> { rs = self.compileFunction(options) })

    # TODO: move to a proper Tea.Prototype object
    rs += fn.compile(proto: self.fullname) for fn of self.methods
    rs += fn.compile(prefix: self.fullname)     for fn of self.statics

    return rs
  end

  def compileFunction(options)
    self.prepareDefinition(options)
    args = self.prepareArguments()

    rs = []
    rs.push self.fullname + ' = ' unless self.isLambda()
    rs.push 'function '
    rs.push '(' + args.definition.join(', ') + ') {'
    rs.push 'var self = this;' if self.isPrototype(options)
    rs.push args.body.join('')
    rs.push self.body.compile(scope: true) if self.body
    rs.push '}'
    rs.push ';' unless self.isLambda()

    # TODO: move to a proper Tea.Prototype object
    if self.parent
      rs.push(self.fullname + '.prototype = new ' + self.parent.compile() + '();')
      rs.push(self.fullname + '.prototype.constructor = ' + self.fullname + ';')
    end

    return rs.join('')
  end

  def prepareDefinition(options)
    return if self.isLambda()
    name = self.name.compile()

    if options.proto
      self.fullname = options.proto + '.prototype.' + name
    elsif options.prefix
      self.fullname = options.prefix + '.' + name
    elsif self.name and self.name instanceof Dot
      self.fullname = name
    else
      scopes.pushIdentifier(name, level: 1)
      self.fullname = name
    end
  end

  def prepareArguments
    definition = []
    body = []

    for arg of self.args
      case arg.constructor
      when Operation
        ident = arg.left.compile()
        definition.push(ident)
        body.push('if (' + ident + ' == null) ' + arg.compile() + ';')
      when Splat
        scopes.pushIdentifier(ident = arg.compile())
        v = 'Array.prototype.slice.call(arguments, ' + definition.length + ') || []'
        body.push('var ' + ident + ' = ' + v + ';')
      else
        scopes.pushIdentifier(arg.compile())
        definition.push(arg.compile())
      end
    end

    return { definition: definition, body: body }
  end

  def extract(type)
    rs = []
    i  = self.body.statements.length

    until i < 0
      i -= 1
      stmt = self.body.statements[i]

      if stmt and stmt instanceof TFunction
        stmt.type = '-' unless stmt.type

        if stmt.type == type
          rs.unshift(stmt)
          self.body.statements.splice(i, 1)
        end
      end
    end
    return rs
  end

  def isPrototype(options)
    return options.proto or ((self.parent or self.methods.length > 0) and
      self.body.statements.length > 0)
  end

  def isLambda
    return !self.name
  end

  #def isDirectDefinition(options)
  #  return !options.prefix && !options.proto && self.name && !(self.name instanceof Dot);
  #end
end

module.exports = TFunction
