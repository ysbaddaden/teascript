scopes    = require('../scopes')
states    = require('../states')
Splat     = require('../expressions/splat')
Dot       = require('../expressions/dot')
Operation = require('../expressions/operation')

def TFunction(name, args, body, parent, type)
  self.name    = name
  self.args    = args || []
  self.body    = body
  self.parent  = parent
  self.type    = type
  self.methods = name ? self.extract('-') : []
  self.statics = name ? self.extract('+') : []

  def compile(options = {})
    rs = nil

    run = -> {
      scopes.withScope(-> { rs = self.compileFunction(options) })
      rs += fn.compile(objectName: self.fullname) for fn of self.methods
      rs += fn.compile(prefix: self.fullname)     for fn of self.statics
    }

    if options.objectName
      state = states.current()
      states.withState({ methodName: self.name.compile() }, run) if state and state.className
    end

    run() unless rs
    return rs
  end

  def compileFunction(options)
    args = self.prepareArguments()

    rs = []
    rs.push(self.definition(options))
    rs.push('(' + args.definition.join(', ') + ') {')
    rs.push('var self = this;') if self.isPrototype(options)
    rs.push(args.body.join('')) if args.body.length > 0

    if self.body
      body = self.body.compile(scope: true)
      rs.push(body) if body.length > 0
    end

    rs.push('}')
    rs.push(';') unless self.isLambda() or self.isDirectDefinition(options)

    if self.parent
      rs.push(self.fullname + '.prototype = new ' + self.parent.compile() + '();');
      rs.push(self.fullname + '.prototype.constructor = ' + self.fullname + ';')
    end

    return rs.join('')
  end

  def definition(options)
    self.prepareDefinition(options)
    return 'function ' + self.fullname if self.isDirectDefinition(options)
    return 'function ' if self.isLambda()
    return self.fullname + ' = function '
  end

  def prepareDefinition(options)
    return if self.isLambda()
    name = self.name.compile()

    if options.objectName
      self.fullname = options.objectName + '.prototype.' + name
    elsif options.prefix
      self.fullname = options.prefix + '.' + name
    elsif self.name and self.name instanceof Dot
      self.fullname = name
    else
      #scopes.pushIdentifier(name, level: 1)
      self.fullname = name
    end
  end

  def prepareArguments
    definition = []
    body = []

    for arg of self.args
      case arg.constructor
      when Operation
        ident = arg.left.compile()
        definition.push(ident)
        body.push('if (' + ident + ' == null) ' + arg.compile() + ';')
      when Splat
        scopes.pushIdentifier(ident = arg.compile())
        v = 'Array.prototype.slice.call(arguments, ' + definition.length + ') || []'
        body.push('var ' + ident + ' = ' + v + ';')
      else
        scopes.pushIdentifier(arg.compile())
        definition.push(arg.compile())
      end
    end

    return { definition: definition, body: body }
  end

  def extract(type)
    rs = []
    i  = self.body.statements.length

    until i < 0
      i -= 1
      stmt = self.body.statements[i]

      if stmt and stmt instanceof TFunction
        stmt.type = '-' unless stmt.type

        if stmt.type == type
          rs.unshift(stmt)
          self.body.statements.splice(i, 1)
        end
      end
    end
    return rs
  end

  def isPrototype(options)
    return options.objectName or ((self.parent or self.methods.length > 0) and self.body.statements.length > 0)
  end

  def isLambda
    return !self.name
  end

  def isDirectDefinition(options)
    return !options.prefix && !options.objectName && self.name && !(self.name instanceof Dot);
  end
end

module.exports = TFunction
