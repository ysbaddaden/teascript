scopes    = require('../scopes')
Splat     = require('../expressions/splat')
Dot       = require('../expressions/dot')
Operation = require('../expressions/operation')

def TFunction
  def init(name, args, body, parent, type)
    self.name    = name
    self.args    = args || []
    self.body    = body
    self.parent  = parent
    self.type    = type
    self.methods = name ? self.extract('-') : []
    self.statics = name ? self.extract('+') : []
    return self
  end

  def compile(options = {})
    rs = null
    scopes.withScope(-> { rs = self.compileFunction(options) })
    return rs
  end

  def extract(type)
    rs = []
    i  = self.body.statements.length
    until i < 0
      i -= 1
      stmt = self.body.statements[i]
      if stmt and stmt instanceof TFunction
        stmt.type = '-' unless stmt.type
        if stmt.type == type
          rs.unshift(stmt)
          self.body.statements.splice(i, 1)
        end
      end
    end
    return rs
  end

  def compileFunction(options)
    rs = []
    a  = []
    b  = []

    self.compileArguments(a, b)
    name = self.compileDefinition(rs, a, options)
    rs.push('var self = this;') if self.isPrototype(options)
    self.compileBody(rs, b, options)

    # inheritance
    if self.parent
      rs.push(name + '.prototype = new ' + self.parent.compile() + '();');
    end

    self.compileMethods(rs, name)

    return rs.join('')
  end

  def compileArguments(a, b)
    for arg of self.args
      case arg.constructor
      when Operation
        ident = arg.left.compile()
        a.push(ident)
        b.push('if (' + ident + ' == null) ' + arg.compile() + ';')
      when Splat
        scopes.pushIdentifier(ident = arg.compile())
        v = 'Array.prototype.slice.call(arguments, ' + a.length + ') || []'
        b.push('var ' + ident + ' = ' + v + ';')
      else
        scopes.pushIdentifier(arg.compile())
        a.push(arg.compile())
      end
    end
  end

  def compileDefinition(rs, a, options)
    if options.objectName
      name = self.name.compile()
      rs.push(options.objectName + '.prototype.' + name + ' = function (' + a.join(', ') + ') {')
    elsif options.prefix
      name = self.name.compile()
      rs.push(options.prefix + '.' + name + ' = function (' + a.join(', ') + ') {')
    elsif self.name and self.name instanceof Dot
      name = self.name.compile()
      rs.push(name + ' = function (' + a.join(', ') + ') {')
    else
      name = self.name ? self.name.compile() : ''
      rs.push('function ' + name + '(' + a.join(', ') + ') {')
    end
    return name
  end

  def compileBody(rs, b, options)
    body = self.body.compile(scope: true) if self.body

    if body.length > 0 || b.length > 0
      rs.push(b.join(''))
      rs.push(body)
    end

    if options.objectName or options.prefix or (self.name and self.name instanceof Dot)
      rs.push('};')
    else
      rs.push('}')
    end
  end

  def compileMethods(rs, name)
    rs.push(fn.compile(objectName: name)) for fn of self.methods
    rs.push(fn.compile(prefix: name))     for fn of self.statics
  end

  def isPrototype(options)
    return options.objectName or ((self.parent or self.methods.length > 0) and self.body.statements.length > 0)
  end
end

module.exports = TFunction
