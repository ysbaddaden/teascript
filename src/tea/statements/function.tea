scopes    = require('../scopes')
Splat     = require('../expressions/splat')
Dot       = require('../expressions/dot')
Operation = require('../expressions/operation')

object TFunction
  def init(name, args, body, parent)
    self.name = name
    self.args = args || []
    self.body = body
    self.parent = parent
    return self
  end

  def compile(options = {})
    rs = null
    scopes.withScope(-> { rs = self.compileFunction(options) })
    return rs
  end

  def compileFunction(options)
    rs   = []
    a    = []
    b    = []
    body = []

    # arguments
    for arg of self.args
      case arg.constructor
      when Operation
        ident = arg.left.compile()
        a.push(ident)
        b.push('if (' + ident + ' == null) ' + arg.compile() + ';')
      when Splat
        scopes.pushIdentifier(ident = arg.compile())
        v = 'Array.prototype.slice.call(arguments, ' + a.length + ') || []'
        b.push('var ' + ident + ' = ' + v + ';')
      else
        scopes.pushIdentifier(arg.compile())
        a.push(arg.compile())
      end
    end

    # function name
    if options.objectName
      name = self.name.compile()
      rs.push(options.objectName + '.prototype.' + name + ' = function (' + a.join(', ') + ') {')
      rs.push('var self = this;')
    elsif options.prefix
      name = self.name.compile()
      rs.push(options.prefix + '.' + name + ' = function (' + a.join(', ') + ') {')
    elsif self.name and self.name instanceof Dot
      name = self.name.compile()
      rs.push(name + ' = function (' + a.join(', ') + ') {')
    else
      name = self.name ? self.name.compile() : ''
      rs.push('function ' + name + '(' + a.join(', ') + ') {')
    end

    # body
    body = self.body.compile(scope: true) if self.body

    if body.length > 0 || b.length > 0
      rs.push(b.join(''))
      rs.push(body)
    end

    if self.name and self.name instanceof Dot
      rs.push('};')
    else
      rs.push('}')
    end
    return rs.join('')
  end
end

module.exports = TFunction
